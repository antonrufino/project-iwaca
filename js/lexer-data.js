const lexerData = [
    {tokenType: 'HAI', tokenRegEx: /^HAI/g, classification: 'Code delimiter'},
    {tokenType: 'KTHXBYE', tokenRegEx: /(?:KTHXBYE\n*)$/g, classification: 'Code delimiter'},
    {tokenType: 'SINGLE_LINE_COMMENT', tokenRegEx: /(BTW) ([^\n]*)/g, classification: ['', 'Comment delimiter', 'Comment text']},
    {tokenType: 'MULTI_LINE_COMMENT', tokenRegEx: /(OBTW) (.*) (TLDR)/g, classification: ['', 'Comment delimiter', 'Comment text', 'Comment delimiter']},
    {tokenType: 'STRING_LITERAL', tokenRegEx: /(")([^"]*)(")/g, classification: ['', 'String delimiter', 'String literal', 'String delimiter']},
    {tokenType: 'NEW_LINE', tokenRegEx: /\n/g, classification: 'Statement delimiter'},
    {tokenType: 'I_HAS_A', tokenRegEx: /I HAS A/g, classification: 'Variable declaration delimiter'},
    {tokenType: 'ITZ', tokenRegEx: /ITZ/g, classification: 'Variable initialization'},
    {tokenType: 'IT', tokenRegEx: /IT/g, classification: 'Implicit variable'},
    {tokenType: 'VISIBLE', tokenRegEx: /VISIBLE/g, classification: 'Output keyword'},
    {tokenType: 'GIMMEH', tokenRegEx: /GIMMEH/g, classification: 'Input keyword'},
    {tokenType: 'WIN', tokenRegEx: /WIN/g, classification: 'TROOF literal'},
    {tokenType: 'FAIL', tokenRegEx: /FAIL/g, classification: 'TROOF literal'},
    {tokenType: 'BOTH_OF', tokenRegEx: /BOTH OF/g, classification: 'Binary logical AND operator'},
    {tokenType: 'EITHER_OF', tokenRegEx: /EITHER OF/g, classification: 'Binary logical OR operator'},
    {tokenType: 'WON_OF', tokenRegEx: /WON OF/g, classification: 'Binary logical XOR operator'},
    {tokenType: 'ALL_OF', tokenRegEx: /ALL OF/g, classification: 'Infinite arity AND'},
    {tokenType: 'ANY_OF', tokenRegEx: /ANY OF/g, classification: 'Infinite arity OR'},
    {tokenType: 'SMOOSH', tokenRegEx: /SMOOSH/g, classification: 'String concatenation operator'},
    {tokenType: 'MKAY', tokenRegEx: /MKAY/g, classification: 'Operation delimiter'},
    {tokenType: 'FAIL', tokenRegEx: /FAIL/g, classification: 'Logical NOT operator'},
    {tokenType: 'O_RLY?', tokenRegEx: /O RLY\?/g, classification: 'if-then statement delimiter'},
    {tokenType: 'OIC', tokenRegEx: /OIC/g, classification: 'Flow control delimiter'},
    {tokenType: 'YA_RLY', tokenRegEx: /YA RLY/g, classification: 'Code block delimiter'},
    {tokenType: 'NO_WAI', tokenRegEx: /NO WAI/g, classification: 'Code block delimiter'},
    {tokenType: 'WTF?', tokenRegEx: /WTF\?/g, classification: 'switch-case statement delimiter'},
    {tokenType: 'OMG', tokenRegEx: /OMG/g, classification: 'Code block delimiter'},
    {tokenType: 'OMGWTF', tokenRegEx: /OMGWTF/g, classification: 'Code block delimiter'},
    {tokenType: 'GTFO', tokenRegEx: /GTFO/g, classification: 'Code block delimiter'},
    {tokenType: 'YARN', tokenRegEx: /YARN/g, classification: 'String variable type'},
    {tokenType: 'NUMBR', tokenRegEx: /NUMBR/g, classification: 'Integer variable type'},
    {tokenType: 'NUMBAR', tokenRegEx: /NUMBAR/g, classification: 'Float variable type'},
    {tokenType: 'TROOF', tokenRegEx: /TROOF/g, classification: 'Boolean variable type'},
    {tokenType: 'NOOB', tokenRegEx: /NOOB/g, classification: 'Untyped variable type'},
    {tokenType: 'SUM_OF', tokenRegEx: /SUM OF/g, classification: 'Addition operator'},
    {tokenType: 'DIFF_OF', tokenRegEx: /DIFF OF/g, classification: 'Subtraction operator'},
    {tokenType: 'PRODUKT_OF', tokenRegEx: /PRODUKT OF/g, classification: 'Multiplication operator'},
    {tokenType: 'QUOSHUNT_OF', tokenRegEx: /QUOSHUNT OF/g, classification: 'Division operator'},
    {tokenType: 'MOD_OF', tokenRegEx: /MOD OF/g, classification: 'Modulo operator'},
    {tokenType: 'BIGGR_OF', tokenRegEx: /BIGGR OF/g, classification: 'Maximum operator'},
    {tokenType: 'SMALLR_OF', tokenRegEx: /SMALLR OF/g, classification: 'Minimum operator'},
    {tokenType: 'AN', tokenRegEx: /AN/g, classification: 'Operand delimiter'},
    {tokenType: 'R', tokenRegEx: / R /g, classification: 'Variable assignment'},
    {tokenType: 'IDENTIFIER', tokenRegEx: /[A-Za-z]\w*/g, classification: 'Identifier'},
    {tokenType: 'INTEGER_LITERAL', tokenRegEx: /(-?\d+)/g, classification: ['', 'Integer literal']},
    {tokenType: 'FLOATING_POINT_LITERAL', tokenRegEx: /(-?(?:\d*)?\.\d+)/g, classification: ['', 'Floating point literal']}
];
