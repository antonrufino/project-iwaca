const lexerData = [
    {tokenType: 'HAI', tokenRegEx: /^HAI/g, classification: 'Code delimiter'},
    {tokenType: 'KTHXBYE', tokenRegEx: /^KTHXBYE/g, classification: 'Code delimiter'},
    {tokenType: ['', 'COMMENT_DELIMITER', 'COMMENT_TEXT', 'COMMENT_DELIMITER'], tokenRegEx: /^(OBTW)((?:.|\n)*)(TLDR)/gm, classification: ['', 'Comment delimiter', 'Comment text', 'Comment delimiter']},
    {tokenType: ['', 'COMMENT_DELIMITER', 'COMMENT_TEXT'], tokenRegEx: /^(BTW) ([^\n]*)/g, classification: ['', 'Comment delimiter', 'Comment text']},
    {tokenType: ['', 'STRING_DELIMITER', 'STRING_LITERAL', 'STRING_DELIMITER'], tokenRegEx: /^(")([^"]*)(")/g, classification: ['', 'String delimiter', 'String literal', 'String delimiter']},
    {tokenType: 'NEW_LINE', tokenRegEx: /^\n/g, classification: 'Statement delimiter'},
    {tokenType: 'I_HAS_A', tokenRegEx: /^I HAS A/g, classification: 'Variable declaration delimiter'},
    {tokenType: 'ITZ', tokenRegEx: /^ITZ/g, classification: 'Variable initialization'},
    {tokenType: 'IDENTIFIER', tokenRegEx: /^IT/g, classification: 'Implicit variable'},
    {tokenType: 'VISIBLE', tokenRegEx: /^VISIBLE/g, classification: 'Output keyword'},
    {tokenType: 'GIMMEH', tokenRegEx: /^GIMMEH/g, classification: 'Input keyword'},
    {tokenType: 'WIN', tokenRegEx: /^WIN/g, classification: 'TROOF literal'},
    {tokenType: 'FAIL', tokenRegEx: /^FAIL/g, classification: 'TROOF literal'},
    {tokenType: 'SMOOSH', tokenRegEx: /^SMOOSH/g, classification: 'String concatenation operator'},
    {tokenType: 'MKAY', tokenRegEx: /^MKAY/g, classification: 'Operation delimiter'},
    {tokenType: 'O_RLY?', tokenRegEx: /^O RLY\?/g, classification: 'if-then statement delimiter'},
    {tokenType: 'OIC', tokenRegEx: /^OIC/g, classification: 'Flow control delimiter'},
    {tokenType: 'YA_RLY', tokenRegEx: /^YA RLY/g, classification: 'Code block delimiter'},
    {tokenType: 'NO_WAI', tokenRegEx: /^NO WAI/g, classification: 'Code block delimiter'},
    {tokenType: 'OMGWTF', tokenRegEx: /^OMGWTF/g, classification: 'Code block delimiter'},
    {tokenType: 'WTF?', tokenRegEx: /^WTF\?/g, classification: 'switch-case statement delimiter'},
    {tokenType: 'OMG', tokenRegEx: /^OMG/g, classification: 'Code block delimiter'},
    {tokenType: 'GTFO', tokenRegEx: /^GTFO/g, classification: 'Code block delimiter'},
    {tokenType: 'YARN', tokenRegEx: /^YARN/g, classification: 'String variable type'},
    {tokenType: 'NUMBR', tokenRegEx: /^NUMBR/g, classification: 'Integer variable type'},
    {tokenType: 'NUMBAR', tokenRegEx: /^NUMBAR/g, classification: 'Float variable type'},
    {tokenType: 'TROOF', tokenRegEx: /^TROOF/g, classification: 'Boolean variable type'},
    {tokenType: 'NOOB', tokenRegEx: /^NOOB/g, classification: 'Untyped variable type'},
    {tokenType: 'OPERATOR', tokenRegEx: /^(?:SUM OF|DIFF OF|PRODUKT OF|QUOSHUNT OF|MOD OF|BOTH OF|EITHER OF|WON OF|NOT|ALL OF|ANY OF|BOTH SAEM|DIFFRINT|BIGGR OF|SMALLR OF)/g, classification: 'Operator'},
    {tokenType: 'AN', tokenRegEx: /^AN/g, classification: 'Operand delimiter'},
    {tokenType: 'R', tokenRegEx: /^R/g, classification: 'Variable assignment'},
    {tokenType: 'IDENTIFIER', tokenRegEx: /^[A-Za-z]\w*/g, classification: 'Identifier'},
    {tokenType: ['', 'FLOATING_POINT_LITERAL'], tokenRegEx: /^(-?(?:\d*)?\.\d+)/g, classification: ['', 'Floating point literal']},
    {tokenType: ['', 'INTEGER_LITERAL'], tokenRegEx: /^(-?\d+)/g, classification: ['', 'Integer literal']},
    {tokenType: 'INVALID', tokenRegEx: /^[^\s]+/, classification: 'Invalid token'}
];
