const lexerData = [
    {tokenType: 'HAI', tokenRegEx: /^HAI/g, classification: 'Code delimiter'},
    {tokenType: 'KTHXBYE', tokenRegEx: /^KTHXBYE/g, classification: 'Code delimiter'},
    {tokenType: 'SINGLE_LINE_COMMENT', tokenRegEx: /^(BTW) ([^\n]*)/g, classification: ['', 'Comment delimiter', 'Comment text']},
    {tokenType: 'MULTI_LINE_COMMENT', tokenRegEx: /^(OBTW) (.*) (TLDR)/g, classification: ['', 'Comment delimiter', 'Comment text', 'Comment delimiter']},
    {tokenType: 'STRING_LITERAL', tokenRegEx: /^(")([^"]*)(")/g, classification: ['', 'String delimiter', 'String literal', 'String delimiter']},
    {tokenType: 'NEW_LINE', tokenRegEx: /^\n/g, classification: 'Statement delimiter'},
    {tokenType: 'I_HAS_A', tokenRegEx: /^I HAS A/g, classification: 'Variable declaration delimiter'},
    {tokenType: 'ITZ', tokenRegEx: /^ITZ/g, classification: 'Variable initialization'},
    {tokenType: 'IT', tokenRegEx: /^IT/g, classification: 'Implicit variable'},
    {tokenType: 'VISIBLE', tokenRegEx: /^VISIBLE/g, classification: 'Output keyword'},
    {tokenType: 'GIMMEH', tokenRegEx: /^GIMMEH/g, classification: 'Input keyword'},
    {tokenType: 'WIN', tokenRegEx: /^WIN/g, classification: 'TROOF literal'},
    {tokenType: 'FAIL', tokenRegEx: /^FAIL/g, classification: 'TROOF literal'},
    {tokenType: 'BOTH_OF', tokenRegEx: /^BOTH OF/g, classification: 'Binary logical AND operator'},
    {tokenType: 'EITHER_OF', tokenRegEx: /^EITHER OF/g, classification: 'Binary logical OR operator'},
    {tokenType: 'WON_OF', tokenRegEx: /^WON OF/g, classification: 'Binary logical XOR operator'},
    {tokenType: 'ALL_OF', tokenRegEx: /^ALL OF/g, classification: 'Infinite arity AND'},
    {tokenType: 'ANY_OF', tokenRegEx: /^ANY OF/g, classification: 'Infinite arity OR'},
    {tokenType: 'SMOOSH', tokenRegEx: /^SMOOSH/g, classification: 'String concatenation operator'},
    {tokenType: 'MKAY', tokenRegEx: /^MKAY/g, classification: 'Operation delimiter'},
    {tokenType: 'FAIL', tokenRegEx: /^FAIL/g, classification: 'Logical NOT operator'},
    {tokenType: 'O_RLY?', tokenRegEx: /^O RLY\?/g, classification: 'if-then statement delimiter'},
    {tokenType: 'OIC', tokenRegEx: /^OIC/g, classification: 'Flow control delimiter'},
    {tokenType: 'YA_RLY', tokenRegEx: /^YA RLY/g, classification: 'Code block delimiter'},
    {tokenType: 'NO_WAI', tokenRegEx: /^NO WAI/g, classification: 'Code block delimiter'},
    {tokenType: 'WTF?', tokenRegEx: /^WTF\?/g, classification: 'switch-case statement delimiter'},
    {tokenType: 'OMG', tokenRegEx: /^OMG/g, classification: 'Code block delimiter'},
    {tokenType: 'OMGWTF', tokenRegEx: /^OMGWTF/g, classification: 'Code block delimiter'},
    {tokenType: 'GTFO', tokenRegEx: /^GTFO/g, classification: 'Code block delimiter'},
    {tokenType: 'YARN', tokenRegEx: /^YARN/g, classification: 'String variable type'},
    {tokenType: 'NUMBR', tokenRegEx: /^NUMBR/g, classification: 'Integer variable type'},
    {tokenType: 'NUMBAR', tokenRegEx: /^NUMBAR/g, classification: 'Float variable type'},
    {tokenType: 'TROOF', tokenRegEx: /^TROOF/g, classification: 'Boolean variable type'},
    {tokenType: 'NOOB', tokenRegEx: /^NOOB/g, classification: 'Untyped variable type'},
    {tokenType: 'SUM_OF', tokenRegEx: /^SUM OF/g, classification: 'Addition operator'},
    {tokenType: 'DIFF_OF', tokenRegEx: /^DIFF OF/g, classification: 'Subtraction operator'},
    {tokenType: 'PRODUKT_OF', tokenRegEx: /^PRODUKT OF/g, classification: 'Multiplication operator'},
    {tokenType: 'QUOSHUNT_OF', tokenRegEx: /^QUOSHUNT OF/g, classification: 'Division operator'},
    {tokenType: 'MOD_OF', tokenRegEx: /^MOD OF/g, classification: 'Modulo operator'},
    {tokenType: 'BIGGR_OF', tokenRegEx: /^BIGGR OF/g, classification: 'Maximum operator'},
    {tokenType: 'SMALLR_OF', tokenRegEx: /^SMALLR OF/g, classification: 'Minimum operator'},
    {tokenType: 'AN', tokenRegEx: /^AN/g, classification: 'Operand delimiter'},
    {tokenType: 'R', tokenRegEx: /^R/g, classification: 'Variable assignment'},
    {tokenType: 'IDENTIFIER', tokenRegEx: /^[A-Za-z]\w*/g, classification: 'Identifier'},
    {tokenType: 'FLOATING_POINT_LITERAL', tokenRegEx: /^(-?(?:\d*)?\.\d+)/g, classification: ['', 'Floating point literal']},
    {tokenType: 'INTEGER_LITERAL', tokenRegEx: /^(-?\d+)/g, classification: ['', 'Integer literal']},
    {tokenType: 'INVALID', tokenRegEx: /^[^\s]+\s+/, classification: 'Invalid token'}
];
